Ram Yadav
UID: 604841556
Paul Eggert


A.)(float) x == (float) dx FALSE: when downcasting takes place from an int to a float, the rounding error occur. At the same time it is possible that downcasting from a double to float can overflow in positive infinity or negative infinity or give something like rounding errors. So, if we use x as a TMAX, it gives special value NaN, and as we know during comparison with NaN, anything including itself result 0, which is False.  B.) dx - dy = (double) (x-y)FALSE: In the LHS, since we have more bits in the double, we will not get overflow and hence will get the mathematically correct result. But for RHS, Say, we have x = INT_MAX and y is any negative number, then we will get x + y when perform x – y. So we will be overflow when operating on the integer in the right hand side and casting up to double will be mathematically incorrect. C.) (dx + dy) + dz == dx + (dy + dz) TRUE: Floating point addition is associativity and it give wrong result. When integers dx, dy, dz are casted to double, it will preserve the precision of original numbers because double has more bits. The same reason also leads not to have rounding error because 32 bits can fit in 52’s bits of the double fraction’s part. Therefore, there would be no rounding error.   D.) (dx * dy) * dz == dx * (dy * dz) FALSE: Double fraction holds 52 bits of fractional bits. So the precision that can be hold would be 2^53-1. So, in multiplication it can be overflow if the result needs more than 52 bits. It could also give rounding error as well. And the rounding error could happens in LHS as well with the same reasoning.  E.) dx/dx == dz/dz FALSE: By the IEEE 754 standard rules, say if dx is non-zero and dz is +0.0, dz/dz would evaluates NaN while dx/dx would be rounded to 1.0. So NaN compare to any values will result false. 